Webservice
├── .pytest_cache
│   ├── CACHEDIR.TAG
│   ├── README.md
│   └── v
│       └── cache
│           ├── lastfailed
│           ├── nodeids
│           └── stepwise
├── Quickstart.md
├── README.md
├── compose.yaml
├── conftest.py
├── docs
│   ├── architecture.png
│   └── diagramme_activite.puml
├── pytest.ini
├── src
│   ├── __init__.py
│   ├── app
│   │   ├── .pytest_cache
│   │   │   ├── CACHEDIR.TAG
│   │   │   ├── README.md
│   │   │   └── v
│   │   │       └── cache
│   │   │           ├── lastfailed
│   │   │           ├── nodeids
│   │   │           └── stepwise
│   │   ├── Dockerfile
│   │   ├── __init__.py
│   │   ├── app.py
│   │   └── requirements.txt
│   ├── ms_banque
│   │   ├── Dockerfile
│   │   ├── Readme.md
│   │   ├── __init__.py
│   │   ├── requirements.txt
│   │   └── server.py
│   ├── ms_fournisseur
│   │   ├── Dockerfile
│   │   ├── Readme.md
│   │   ├── __init__.py
│   │   └── server.py
│   ├── ms_montantmax
│   │   ├── Dockerfile
│   │   ├── Readme.md
│   │   ├── __init__.py
│   │   ├── montantmax.proto
│   │   ├── montantmax_pb2.py
│   │   ├── montantmax_pb2_grpc.py
│   │   └── server.py
│   └── ms_profilrisque
│       ├── Dockerfile
│       ├── Readme.md
│       ├── __init__.py
│       └── server.py
└── tests
    ├── test_app.py
    ├── test_ms_banque.py
    ├── test_ms_fournisseur.py
    ├── test_ms_montantmax.py
    └── test_ms_profilrisque.py

================================================================================
Chemin relatif: conftest.py
# conftest.py
import sys, os

# racine du projet
ROOT = os.path.dirname(__file__)

# 1) ajouter src/ au PYTHONPATH pour importer app.app, ms_banque, ms_profilrisque, etc.
sys.path.insert(0, os.path.abspath(os.path.join(ROOT, 'src')))

# 2) ajouter src/ms_montantmax/ au PYTHONPATH pour que
#    `import montantmax_pb2` dans montantmax_pb2_grpc.py fonctionne
sys.path.insert(0, os.path.abspath(os.path.join(ROOT, 'src', 'ms_montantmax')))

================================================================================
Chemin relatif: Quickstart.md
# Guide Quickstart

Ce guide rapide vous permet de démarrer et de tester l’application en moins de 5 minutes.

### 1. Cloner le dépôt

```bash
git clone https://github.com/AdrienBenthami/Webservice.git
cd Webservice
```

### 2. Démarrer tous les services en conteneurs

```bash
docker compose up --build -d
```

### 3. Vérifier que tout est sain

```bash
docker compose ps
```

Assurez-vous que chaque service affiche un état `healthy`.

### 4. Tester un flux complet

1. **Soumettre une demande** (pas de chèque pour l’instant) :

   ```bash
   curl -X POST http://localhost:5000/loan \
     -H "Content-Type: application/json" \
     -d '{"id":"client1","personal_info":"M. Dupont","loan_amount":8000}'
   ```

   * Vous obtiendrez un JSON avec `status":"pending"` et un `request_id`.

2. **Consulter le statut** :

   ```bash
   curl http://localhost:5000/loan/status/<request_id>
   ```

   * Devrait retourner `pending`.

3. **Simuler dépôt du chèque** (par défaut, `ms_banque` renvoie `valid`) :

   ```bash
   curl -X POST http://localhost:5000/loan/callback \
     -H "Content-Type: text/xml" \
     --data '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"><soapenv:Body><ChequeStatusResponse><request_id>'<request_id>'</request_id><status>done</status><verdict>Chèque validé</verdict></ChequeStatusResponse></soapenv:Body></soapenv:Envelope>'
   ```

4. **Vérifier le statut final** :

   ```bash
   curl http://localhost:5000/loan/status/<request_id>
   ```

   * Vous devriez obtenir `status":"approved"`.

Félicitations ! Votre application de prêt fonctionne.
================================================================================
Chemin relatif: compose.yaml
services:
  redis:
    image: redis:6-alpine
    container_name: msb_redis
    ports:
      - "6379:6379"
    networks:
      - webservice

  ms_montantmax:
    build: ./src/ms_montantmax
    ports:
      - "50051:50051"
    healthcheck:
      test: ["CMD-SHELL", "nc -z localhost 50051 || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - webservice
    restart: unless-stopped

  ms_profilrisque:
    build: ./src/ms_profilrisque
    ports:
      - "5001:5001"
    depends_on:
      - ms_montantmax
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5001/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - webservice
    restart: unless-stopped

  ms_banque:
    build: ./src/ms_banque
    ports:
      - "5002:5002"
    depends_on:
      - redis
      - ms_profilrisque
    healthcheck:
      test: ["CMD-SHELL", "nc -z localhost 5002 || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - webservice
    restart: unless-stopped

  ms_fournisseur:
    build: ./src/ms_fournisseur
    ports:
      - "5003:5003"
    depends_on:
      - ms_banque
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5003/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - webservice
    restart: unless-stopped

  app:
    build: 
      context: .
      dockerfile: src/app/Dockerfile
    ports:
      - "5000:5000"
    depends_on:
      ms_montantmax:
        condition: service_healthy
      ms_profilrisque:
        condition: service_healthy
      ms_banque:
        condition: service_healthy
      ms_fournisseur:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5000/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - webservice
    restart: unless-stopped

networks:
  webservice:
    driver: bridge

================================================================================
Chemin relatif: pytest.ini
[pytest]
minversion = 6.0
addopts = -ra -q
testpaths = tests
# Empêche pytest de descendre dans src/test
norecursedirs = src/test
================================================================================
Chemin relatif: README.md
## Fichier : README.md

# Application Compagnon – README détaillé

## Table des matières

1. [Présentation](#présentation)
2. [Architecture](#architecture)
3. [Prérequis](#prérequis)
4. [Installation](#installation)
5. [Configuration](#configuration)
6. [Démarrage des microservices](#démarrage-des-microservices)
7. [Démarrage de l’application compagnon](#démarrage-de-lapplication-compagnon)
8. [Endpoints](#endpoints)
9. [Tests](#tests)
10. [Contribuer](#contribuer)
11. [Licence](#licence)

---

## Présentation

L’**Application Compagnon** orchestre un workflow de demande de prêt en interagissant avec plusieurs micro-services :

* **ms\_montantmax** (gRPC) : vérification du montant maximal autorisé.
* **ms\_profilrisque** (GraphQL) : évaluation du profil de risque client.
* **ms\_banque** (SOAP asynchrone) : validation du chèque de banque.
* **ms\_fournisseur** (REST) : libération et transfert des fonds.

Chaque service est containerisé et déployé via Docker Compose.

## Architecture

![Diagramme d’architecture](docs/architecture.png)

1. Le client envoie une requête POST `/loan` à l’app Flask.
2. L’app appelle le service gRPC **ms\_montantmax** pour vérifier le montant.
3. Si validé, elle interroge **ms\_profilrisque** via GraphQL.
4. Si le risque est acceptable, elle soumet un chèque à **ms\_banque** (SOAP async).
5. Une fois le callback reçu, elle interroge **ms\_fournisseur** pour le transfert.

Le dossier `docs/` contient des diagrammes UML détaillés.

## Prérequis

* **Docker** & **Docker Compose**
* **Python 3.10+** (pour exécution locale hors conteneur)
* **Redis** (utilisé par `ms_banque`, géré via Docker)

## Installation

1. Cloner ce dépôt :

   ```bash
   git clone https://github.com/AdrienBenthami/Webservice.git
   cd Webservice
   ```
2. (Optionnel) Créer un environnement virtuel pour tests locaux :

   ```bash
   python3 -m venv venv
   source venv/bin/activate
   pip install -r src/app/requirements.txt
   ```

## Configuration

* Le fichier `compose.yaml` expose tous les ports nécessaires :

  * 50051 (gRPC MontantMax)
  * 5001 (GraphQL ProfilRisque)
  * 5002 (SOAP Banque)
  * 5003 (REST Fournisseur)
  * 5000 (Flask App)
* Les URLs de chaque service sont configurées dans `src/app/app.py` via les variables :

  ```python
  MS_MONTANTMAX_ADDRESS = 'localhost:50051'
  MS_PROFILRISQUE_URL  = 'http://localhost:5001/graphql'
  MS_BANQUE_URL         = 'http://localhost:5002/'
  MS_FOURNISSEUR_URL    = 'http://localhost:5003/fundTransfers'
  ```

## Démarrage des microservices

Depuis la racine du projet :

```bash
docker compose up --build -d
```

Vérifiez l’état des services :

```bash
docker compose ps
```

## Démarrage de l’application compagnon

Si vous utilisez Docker Compose, le service `app` démarre automatiquement.

Pour un lancement local sans conteneurs :

```bash
cd src/app
source venv/bin/activate  # si utilisé
pip install -r requirements.txt
python app.py
```

L’application écoute sur le port **5000**.

## Endpoints

### Application Flask (/app)

| Méthode | Endpoint                    | Description                                   |
| ------- | --------------------------- | --------------------------------------------- |
| GET     | `/health`                   | Vérifie que l’app est opérationnelle.         |
| POST    | `/loan`                     | Soumettre une demande de prêt.                |
| GET     | `/loan/status/{request_id}` | Récupérer le statut de la demande.            |
| POST    | `/loan/callback`            | Point de callback SOAP interne (automatique). |

### ms\_fournisseur (REST)

| Méthode | Endpoint                     | Description                   |
| ------- | ---------------------------- | ----------------------------- |
| GET     | `/health`                    | Healthcheck.                  |
| POST    | `/fundTransfers`             | Créer un transfert de fonds.  |
| GET     | `/fundTransfers/{id}/status` | Statut du transfert de fonds. |

### ms\_profilrisque (GraphQL)

* Endpoint unique : `/graphql`
* Requête :

  ```graphql
  query($loanAmount: Float!, $clientInfo: String!) {
    riskProfile(loanAmount: $loanAmount, clientInfo: $clientInfo)
  }
  ```

### ms\_montantmax (gRPC)

* Service : `ms_montantmax.MontantMaxService`
* Méthode : `CheckLoan(LoanRequest) returns LoanResponse`
* Exemple de commande `grpcurl` dans `src/ms_montantmax/Readme.md`.

## Tests

Exécuter l’ensemble des tests unitaires et d’intégration :

```bash
pytest -q
```

Le fichier `pytest.ini` est préconfiguré pour le dossier `tests/`.




================================================================================
Chemin relatif: docs/diagramme_activite.puml
@startuml
|Client|
start
:Remplir le formulaire de demande de prêt\n(ID, infos personnelles, type, montant, description);
:Soumettre le formulaire via API REST\nà l'Application Compagnon;

|Application Compagnon|
:Recevoir la demande de prêt;
:Appeler MS MontantMax [gRPC] pour vérifier le montant;

partition "MS MontantMax" {
  :Vérifier que le montant demandé est ≤ plafond autorisé;
  if (Montant > plafond?) then (Oui)
    :Retourner échec;
  else (Non)
    :Retourner succès;
  endif
}

if (Montant > plafond?) then (Oui)
  :Préparer notification de refus :\n"Montant trop élevé";
else (Non)
  :Appeler MS ProfilRisque [GraphQL] avec les infos client;
  partition "MS ProfilRisque" {
    :Analyser le profil financier et déterminer le risque;
    if (Risque = élevé \net Montant ≥ 20000?) then (Oui)
      :Retourner "Risque élevé";
    else (Non)
      :Retourner "Risque acceptable";
    endif
  }
  if (Risque élevé et Montant ≥ 20000?) then (Oui)
    :Préparer notification de refus :\n"Risque trop élevé";
  else (Non)
    :Demander au client de soumettre un chèque de banque;
    |Client|
    :Envoyer le chèque de banque;
    |Application Compagnon|
    :Appeler MS Banque [SOAP] pour valider le chèque;
    partition "MS Banque" {
      :Simuler la validation du chèque;
      if (Chèque valide?) then (Oui)
        :Retourner "Chèque validé";
      else (Non)
        :Retourner "Chèque invalide";
      endif
    }
    if (Chèque invalide?) then (Oui)
      :Préparer notification de refus :\n"Chèque invalide";
    else (Non)
      :Appeler MS Fournisseur [REST] pour demander les fonds;
      partition "MS Fournisseur" {
        :Demander la libération des fonds;
        :Transférer le montant sur le compte bancaire du client;
        :Retourner succès;
      }
      :Préparer notification d'approbation :\n"Prêt approuvé et fonds transférés";
    endif
  endif
endif

:Notifier le client via REST;
|Client|
:Recevoir notification;
stop
@enduml

================================================================================
Chemin relatif: docs/architecture.png
Erreur de lecture: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
================================================================================
Chemin relatif: tests/test_ms_montantmax.py
import pytest
from ms_montantmax.server import MontantMaxService
from ms_montantmax import montantmax_pb2

@pytest.fixture
def service():
    return MontantMaxService()

def test_checkloan_within_limit(service):
    req = montantmax_pb2.LoanRequest(loan_amount=1000)
    resp = service.CheckLoan(req, None)
    assert resp.allowed is True
    assert "Demande acceptée" in resp.message

def test_checkloan_above_limit(service):
    req = montantmax_pb2.LoanRequest(loan_amount=60000)
    resp = service.CheckLoan(req, None)
    assert resp.allowed is False
    assert "Montant trop élevé" in resp.message

================================================================================
Chemin relatif: tests/test_ms_profilrisque.py
import pytest
from ms_profilrisque.server import app

GRAPHQL_QUERY = '''
query($loanAmount: Float!, $clientInfo: String!) {
  riskProfile(loanAmount: $loanAmount, clientInfo: $clientInfo)
}
'''

@pytest.fixture
def client():
    with app.test_client() as c:
        yield c

def test_risk_profile_acceptable(client):
    payload = {
        "query": GRAPHQL_QUERY,
        "variables": {"loanAmount": 1000, "clientInfo": "Test"}
    }
    rv = client.post('/graphql', json=payload)
    assert rv.status_code == 200
    assert rv.get_json()['riskProfile'] == 'acceptable'

def test_risk_profile_eleve(client):
    payload = {
        "query": GRAPHQL_QUERY,
        "variables": {"loanAmount": 25000, "clientInfo": "Test"}
    }
    rv = client.post('/graphql', json=payload)
    assert rv.status_code == 200
    assert rv.get_json()['riskProfile'] == 'elevé'

================================================================================
Chemin relatif: tests/test_ms_fournisseur.py
import pytest
from ms_fournisseur.server import app

@pytest.fixture
def client():
    with app.test_client() as c:
        yield c

def test_health(client):
    rv = client.get('/health')
    assert rv.status_code == 200
    assert rv.get_json() == {"status": "ok"}

def test_create_fund_transfer(client):
    payload = {"loan_amount": 12345, "client_id": "clientX"}
    rv = client.post('/fundTransfers', json=payload)
    assert rv.status_code == 201
    j = rv.get_json()
    assert j["status"] == "success"
    assert "Fonds de 12345" in j["message"]
    assert "self" in j["links"] and "status" in j["links"]

def test_get_fund_transfer_status(client):
    rv = client.get('/fundTransfers/1234/status')
    assert rv.status_code == 200
    assert rv.get_json()["status"] == "completed"

================================================================================
Chemin relatif: tests/test_app.py
import pytest
import grpc
from flask import json
from xml.etree import ElementTree as ET

from app.app import app as flask_app, MS_BANQUE_URL, MS_PROFILRISQUE_URL, MS_FOURNISSEUR_URL
from ms_montantmax import montantmax_pb2_grpc

# Stub pour gRPC MontantMax
class DummyLoanResponse:
    def __init__(self, allowed, message):
        self.allowed = allowed
        self.message = message

class FakeMontantStub:
    def __init__(self, _):
        pass

    def CheckLoan(self, request):
        if request.loan_amount <= 50000:
            return DummyLoanResponse(True, "Demande acceptée")
        return DummyLoanResponse(False, "Montant trop élevé")


# DummyResponse pour simuler requests.post
class DummyResponse:
    def __init__(self, status_code=200, content=b'', text='', json_data=None):
        self.status_code = status_code
        self.content = content
        self.text = text
        self._json = json_data or {}

    def json(self):
        return self._json

    @property
    def ok(self):
        return self.status_code == 200


@pytest.fixture(autouse=True)
def mock_services(monkeypatch):
    # gRPC stub
    monkeypatch.setattr(grpc, 'insecure_channel', lambda addr: None)
    monkeypatch.setattr(montantmax_pb2_grpc, 'MontantMaxServiceStub', FakeMontantStub)

    # requests.post fake
    def fake_post(url, data=None, json=None, headers=None, timeout=None):
        # GraphQL risk
        if url == MS_PROFILRISQUE_URL:
            amt = json['variables']['loanAmount']
            risk = 'acceptable' if amt < 20000 else 'elevé'
            return DummyResponse(json_data={'riskProfile': risk})

        # SubmitChequeRequest SOAP
        if url == MS_BANQUE_URL:
            # renvoyer un XML avec un request_id fixe
            xml = b"""<?xml version='1.0' encoding='UTF-8'?>
<soap11env:Envelope xmlns:soap11env="http://schemas.xmlsoap.org/soap/envelope/"
                   xmlns:tns="ms.banque.async">
  <soap11env:Body>
    <tns:SubmitChequeRequestResponse>
      <tns:SubmitChequeRequestResult>fixed-uuid-1234</tns:SubmitChequeRequestResult>
    </tns:SubmitChequeRequestResponse>
  </soap11env:Body>
</soap11env:Envelope>"""
            return DummyResponse(content=xml, text=xml.decode())

        # Demande de financement REST
        if url == MS_FOURNISSEUR_URL:
            return DummyResponse(status_code=200, json_data={'status': 'success'})

        return DummyResponse(status_code=404)

    monkeypatch.setattr("requests.post", fake_post)


@pytest.fixture
def client():
    with flask_app.test_client() as c:
        yield c


def test_missing_data(client):
    rv = client.post('/loan')
    assert rv.status_code == 400
    js = rv.get_json()
    assert js['status'] == 'error'


def test_invalid_amount_type(client):
    rv = client.post('/loan', json={'id':'1','personal_info':'x','loan_amount':'abc'})
    assert rv.status_code == 400
    assert rv.get_json()['reason'].startswith("Le montant doit être un nombre")


def test_grpc_refuse(client):
    rv = client.post('/loan', json={'id':'1','personal_info':'x','loan_amount':60000})
    assert rv.status_code == 400
    assert rv.get_json()['status'] == 'refused'


def test_risk_refusal(client):
    rv = client.post('/loan', json={'id':'1','personal_info':'x','loan_amount':25000})
    assert rv.status_code == 400
    assert rv.get_json()['reason'] == 'Risque trop élevé'


def test_flow_async_success(client):
    # 1) soumission de la demande
    rv = client.post('/loan', json={'id':'1','personal_info':'x','loan_amount':10000})
    assert rv.status_code == 200
    js = rv.get_json()
    assert js['status'] == 'pending'
    req_id = js['request_id']

    # 2) avant callback, status pending
    rv2 = client.get(f'/loan/status/{req_id}')
    assert rv2.status_code == 200
    assert rv2.get_json()['status'] == 'pending'

    # 3) simulate callback valide
    soap = f"""<?xml version="1.0"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  <soapenv:Body>
    <ChequeStatusResponse>
      <request_id>{req_id}</request_id>
      <status>done</status>
      <verdict>Chèque validé</verdict>
    </ChequeStatusResponse>
  </soapenv:Body>
</soapenv:Envelope>"""
    rv3 = client.post('/loan/callback', data=soap, content_type='text/xml')
    assert rv3.status_code == 200

    # 4) après callback, status approved
    rv4 = client.get(f'/loan/status/{req_id}')
    assert rv4.status_code == 200
    out = rv4.get_json()
    assert out['status'] == 'approved'
    assert 'fonds' in out['message']


def test_flow_async_invalid(client):
    # même soumission
    rv = client.post('/loan', json={'id':'1','personal_info':'x','loan_amount':10000})
    req_id = rv.get_json()['request_id']

    # callback invalide
    soap = f"""<?xml version="1.0"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  <soapenv:Body>
    <ChequeStatusResponse>
      <request_id>{req_id}</request_id>
      <status>done</status>
      <verdict>Chèque invalide</verdict>
    </ChequeStatusResponse>
  </soapenv:Body>
</soapenv:Envelope>"""
    client.post('/loan/callback', data=soap, content_type='text/xml')

    # status refused
    rv2 = client.get(f'/loan/status/{req_id}')
    assert rv2.status_code == 400
    assert rv2.get_json()['status'] == 'refused'

================================================================================
Chemin relatif: tests/test_ms_banque.py
import sys
import pytest
# module‐level skip si Python > 3.10
if sys.version_info >= (3, 11):
    pytest.skip("Les tests de ms_banque nécessitent Spyne <-= 3.10", allow_module_level=True)
    
    
from spyne.server.wsgi import WsgiApplication
from ms_banque.server import application, r
from werkzeug.test import Client
from werkzeug.wrappers import Response
from lxml import etree


@pytest.fixture(autouse=True)
def flush_redis():
    r.flushdb()
    yield
    r.flushdb()

@pytest.fixture
def client():
    wsgi_app = WsgiApplication(application)
    return Client(wsgi_app, Response)

def _parse_response(resp):
    return etree.fromstring(resp.data)

def test_submit_and_get_and_upload_and_get(client):
    # 1) SubmitChequeRequest
    submit_soap = b'''<?xml version="1.0"?>\
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">\
<soapenv:Body><SubmitChequeRequest xmlns="ms.banque.async"/></soapenv:Body></soapenv:Envelope>'''
    resp1 = client.post('/', data=submit_soap, headers={'Content-Type':'application/soap+xml'})
    assert resp1.status_code == 200
    tree1 = _parse_response(resp1)
    ns = {'tns':'ms.banque.async'}
    req_id = tree1.findtext('.//tns:SubmitChequeRequestResult', namespaces=ns)
    assert req_id

    # 2) GetChequeStatus → pending
    get_soap = f'''<?xml version="1.0"?>\
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">\
<soapenv:Body><GetChequeStatus xmlns="ms.banque.async">\
<request_id>{req_id}</request_id></GetChequeStatus>\
</soapenv:Body></soapenv:Envelope>'''.encode()
    resp2 = client.post('/', data=get_soap, headers={'Content-Type':'text/xml'})
    tree2 = _parse_response(resp2)
    assert tree2.findtext('.//tns:status', namespaces=ns) == 'pending'

    # 3) UploadCheque → valid
    upload_soap = f'''<?xml version="1.0"?>\
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">\
<soapenv:Body><UploadCheque xmlns="ms.banque.async">\
<request_id>{req_id}</request_id><cheque>valid</cheque>\
</UploadCheque></soapenv:Body></soapenv:Envelope>'''.encode()
    resp3 = client.post('/', data=upload_soap, headers={'Content-Type':'text/xml'})
    assert resp3.status_code == 200

    # 4) GetChequeStatus → done + Chèque validé
    resp4 = client.post('/', data=get_soap, headers={'Content-Type':'text/xml'})
    tree4 = _parse_response(resp4)
    assert tree4.findtext('.//tns:status', namespaces=ns) == 'done'
    assert tree4.findtext('.//tns:verdict', namespaces=ns) == 'Chèque validé'

================================================================================
Chemin relatif: .pytest_cache/CACHEDIR.TAG
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

================================================================================
Chemin relatif: .pytest_cache/README.md
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

================================================================================
Chemin relatif: .pytest_cache/v/cache/stepwise
[]
================================================================================
Chemin relatif: .pytest_cache/v/cache/lastfailed
{
  "src/test/test_montantmax.py": true,
  "tests/test/test_montantmax.py": true
}
================================================================================
Chemin relatif: .pytest_cache/v/cache/nodeids
[
  "tests/test_app.py::test_flow_async_invalid",
  "tests/test_app.py::test_flow_async_success",
  "tests/test_app.py::test_grpc_refuse",
  "tests/test_app.py::test_invalid_amount_type",
  "tests/test_app.py::test_invalid_check",
  "tests/test_app.py::test_missing_data",
  "tests/test_app.py::test_pending_no_check",
  "tests/test_app.py::test_risk_refusal",
  "tests/test_app.py::test_success_flow",
  "tests/test_ms_fournisseur.py::test_create_fund_transfer",
  "tests/test_ms_fournisseur.py::test_get_fund_transfer_status",
  "tests/test_ms_fournisseur.py::test_health",
  "tests/test_ms_montantmax.py::test_checkloan_above_limit",
  "tests/test_ms_montantmax.py::test_checkloan_within_limit",
  "tests/test_ms_profilrisque.py::test_risk_profile_acceptable",
  "tests/test_ms_profilrisque.py::test_risk_profile_eleve"
]
================================================================================
Chemin relatif: src/__init__.py

================================================================================
Chemin relatif: src/ms_fournisseur/__init__.py

================================================================================
Chemin relatif: src/ms_fournisseur/Dockerfile
# Utiliser une image Python 3.10 slim
FROM python:3.13-slim

# Définir le répertoire de travail dans le conteneur
WORKDIR /app

# Installer curl et netcat-openbsd pour les healthchecks
RUN apt-get update && apt-get install -y curl

# Mettre à jour pip et installer Flask (et autres dépendances si besoin)
RUN pip install --upgrade pip && \
    pip install flask

# Copier le code source dans le conteneur
COPY . .

# Exposer le port utilisé par l’application (5003)
EXPOSE 5003

# Lancer l’application
CMD ["python", "server.py"]

================================================================================
Chemin relatif: src/ms_fournisseur/server.py
from flask import Flask, request, jsonify

app = Flask(__name__)
app.config['JSON_AS_ASCII'] = False

# Endpoint pour créer un transfert de fonds (ressource : fundTransfers)
@app.route('/fundTransfers', methods=['POST'])
def create_fund_transfer():
    data = request.json
    loan_amount = data.get("loan_amount")
    client_id = data.get("client_id")
    # Dans une application réelle, on générerait un identifiant unique et on enregistrerait la demande.
    transfer_id = "1234"  # Exemple statique
    response = {
        "status": "success",
        "message": f"Fonds de {loan_amount} transférés pour le client {client_id}",
        "links": {
            "self": f"/fundTransfers/{transfer_id}",
            "status": f"/fundTransfers/{transfer_id}/status"
        }
    }
    return jsonify(response), 201

# Endpoint pour consulter l'état d'un transfert (simulation)
@app.route('/fundTransfers/<transfer_id>/status', methods=['GET'])
def get_fund_transfer_status(transfer_id):
    # Ici, on simule toujours un statut "completed"
    return jsonify({
        "transfer_id": transfer_id,
        "status": "completed"
    }), 200

# Endpoint dédié au healthcheck
@app.route('/health', methods=['GET'])
def health():
    return jsonify({"status": "ok"}), 200

if __name__ == '__main__':
    app.run(host="0.0.0.0", port=5003)

================================================================================
Chemin relatif: src/ms_fournisseur/Readme.md
Pour tester:
```sh
python server.py
```
Ou en docker :
```sh
docker build -t ms_fournisseur .
docker run -d -p 5003:5003 ms_fournisseur
```

Dans un autre terminal :
```sh
curl http://localhost:5003/health
```

```sh
curl -X POST -H "Content-Type: application/json" \
  -d '{"loan_amount": 15000, "client_id": "client123"}' \
  http://localhost:5003/fundTransfers
```

Réponse : 
```sh
{
  "status": "success",
  "message": "Fonds de 15000 transférés pour le client client123"
}

```
================================================================================
Chemin relatif: src/ms_banque/requirements.txt
spyne
lxml
redis
requests
================================================================================
Chemin relatif: src/ms_banque/__init__.py

================================================================================
Chemin relatif: src/ms_banque/Dockerfile
# Utiliser une image Python 3.10 slim, compatible avec Spyne
FROM python:3.10-slim

# Définir le répertoire de travail dans le conteneur
WORKDIR /app

# Installer curl et netcat-openbsd pour les healthchecks
RUN apt-get update && apt-get install -y netcat-openbsd

# Copier le fichier des dépendances dans le conteneur
COPY requirements.txt .

# Installer les dépendances
RUN pip install --upgrade pip && \
    pip install -r requirements.txt

# Copier l'intégralité du code du microservice dans le conteneur
COPY . .

# Exposer le port utilisé par le service SOAP
EXPOSE 5002

# Lancer le service en exécutant le fichier server.py
CMD ["python", "server.py"]

================================================================================
Chemin relatif: src/ms_banque/server.py
from spyne import Application, rpc, ServiceBase, Unicode, ComplexModel
from spyne.protocol.soap import Soap11
from spyne.server.wsgi import WsgiApplication
from lxml import etree
import redis, uuid, threading, requests

r = redis.Redis(host='redis', port=6379, db=0, decode_responses=True)

class ChequeStatus(ComplexModel):
    status  = Unicode
    verdict = Unicode

def send_callback(request_id, reply_to, relates_to, verdict):
    NS_WSA = 'http://www.w3.org/2005/08/addressing'
    root = etree.Element(
        "{http://schemas.xmlsoap.org/soap/envelope/}Envelope",
        nsmap={None:"http://schemas.xmlsoap.org/soap/envelope/", 'wsa':NS_WSA}
    )
    hdr = etree.SubElement(root, "{http://schemas.xmlsoap.org/soap/envelope/}Header")
    etree.SubElement(hdr, f"{{{NS_WSA}}}MessageID").text   = str(uuid.uuid4())
    etree.SubElement(hdr, f"{{{NS_WSA}}}RelatesTo").text   = relates_to
    etree.SubElement(hdr, f"{{{NS_WSA}}}To").text         = reply_to

    body = etree.SubElement(root, "{http://schemas.xmlsoap.org/soap/envelope/}Body")
    resp = etree.SubElement(body, "ChequeStatusResponse")
    etree.SubElement(resp, "request_id").text = request_id
    etree.SubElement(resp, "status").text     = "done"
    etree.SubElement(resp, "verdict").text    = verdict

    xml = etree.tostring(root, xml_declaration=True, encoding='utf-8')
    try:
        requests.post(
            reply_to,
            data=xml,
            headers={'Content-Type':'application/soap+xml; charset=utf-8'},
            timeout=5
        )
    except:
        pass

class BanqueAsync(ServiceBase):
    __namespace__ = 'ms.banque.async'

    @rpc(_returns=Unicode)
    def SubmitChequeRequest(ctx):
        tree       = ctx.in_document
        ns_wsa     = {'wsa':'http://www.w3.org/2005/08/addressing'}
        reply_to   = tree.findtext('.//wsa:ReplyTo/wsa:Address', namespaces=ns_wsa) or ''
        relates_to = tree.findtext('.//wsa:MessageID',      namespaces=ns_wsa) or ''

        req_id = str(uuid.uuid4())
        r.hset(req_id, mapping={
            'status':     'pending',
            'verdict':    '',
            'reply_to':   reply_to,
            'relates_to': relates_to
        })
        return req_id

    @rpc(Unicode, Unicode, _returns=None)
    def UploadCheque(ctx, request_id, cheque):
        data = r.hgetall(request_id)
        if not data:
            return None
        verdict = "Chèque validé" if cheque == 'valid' else "Chèque invalide"
        r.hset(request_id, mapping={'status':'done','verdict':verdict})
        threading.Thread(
            target=send_callback,
            args=(request_id, data['reply_to'], data['relates_to'], verdict),
            daemon=True
        ).start()
        return None

    @rpc(Unicode, _returns=ChequeStatus)
    def GetChequeStatus(ctx, request_id):
        if not r.exists(request_id):
            return ChequeStatus(status='unknown', verdict='')
        d = r.hgetall(request_id)
        return ChequeStatus(status=d['status'], verdict=d.get('verdict',''))

application = Application(
    [BanqueAsync],
    tns='ms.banque.async',
    in_protocol=Soap11(validator='lxml'),
    out_protocol=Soap11()
)

if __name__ == '__main__':
    from wsgiref.simple_server import make_server
    srv = make_server('0.0.0.0', 5002, WsgiApplication(application))
    srv.serve_forever()

================================================================================
Chemin relatif: src/ms_banque/Readme.md
# ms\_banque – Service SOAP Asynchrone de Validation de Chèque

Ce micro-service simule une banque :

* Il garde en mémoire une demande de chèque (état `pending`).
* Il permet de consulter ce statut (`pending` → `done`).
* Il reçoit le dépôt du chèque (`valid` ou `invalid`), passe l’état à `done` et stocke le verdict.

---

## Prérequis

* Python 3.10+
* Redis (local ou via Docker)
* curl (pour les tests)
* (Optionnel) xmllint pour formater la sortie XML

---

## Installation

1. Placez-vous dans `Webservice/src/ms_banque`
2. Créez et activez un environnement virtuel :

   ```
   python3 -m venv env
   source env/bin/activate
   ```
3. Installez les dépendances :

   ```
   pip install -r requirements.txt
   ```
4. Lancez Redis si nécessaire :

   ```
   docker run -d --name msb_redis -p 6379:6379 redis:6-alpine
   ```

---

## Démarrage du service

```
cd Webservice/src/ms_banque
python server.py
```

Le service écoute sur **[http://0.0.0.0:5002/](http://0.0.0.0:5002/)**.

---

## Tests manuels avec curl

Vous allez exécuter **4 étapes**, une par une. Copiez-collez tel quel.

### Étape 1 – SubmitChequeRequest

```
curl -X POST http://localhost:5002/ \
  -H "Content-Type: application/soap+xml; charset=utf-8" \
  --data '<?xml version="1.0" encoding="utf-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:asy="ms.banque.async"
                  xmlns:wsa="http://www.w3.org/2005/08/addressing">
  <soapenv:Header>
    <wsa:MessageID>uuid-1</wsa:MessageID>
    <wsa:ReplyTo><wsa:Address>http://localhost:9000/loan/callback</wsa:Address></wsa:ReplyTo>
  </soapenv:Header>
  <soapenv:Body>
    <asy:SubmitChequeRequest/>
  </soapenv:Body>
</soapenv:Envelope>'
```

**Réponse attendue**

```xml
<soap11env:Envelope …>
  <soap11env:Body>
    <tns:SubmitChequeRequestResponse>
      <tns:SubmitChequeRequestResult>YOUR_REQUEST_ID</tns:SubmitChequeRequestResult>
    </tns:SubmitChequeRequestResponse>
  </soap11env:Body>
</soap11env:Envelope>
```

Notez **YOUR\_REQUEST\_ID** (UUID).

---

### Étape 2 – GetChequeStatus (avant dépôt)

```
curl -X POST http://localhost:5002/ \
  -H "Content-Type: text/xml; charset=utf-8" \
  --data '<?xml version="1.0" encoding="utf-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:asy="ms.banque.async">
  <soapenv:Body>
    <asy:GetChequeStatus>
      <asy:request_id>YOUR_REQUEST_ID</asy:request_id>
    </asy:GetChequeStatus>
  </soapenv:Body>
</soapenv:Envelope>'
```

**Réponse attendue**

```xml
<soap11env:Envelope …>
  <soap11env:Body>
    <tns:GetChequeStatusResponse>
      <tns:GetChequeStatusResult>
        <tns:status>pending</tns:status>
        <tns:verdict/>
      </tns:GetChequeStatusResult>
    </tns:GetChequeStatusResponse>
  </soap11env:Body>
</soap11env:Envelope>
```

---

### Étape 3 – UploadCheque (dépôt du chèque)

```
curl -X POST http://localhost:5002/ \
  -H "Content-Type: text/xml; charset=utf-8" \
  --data '<?xml version="1.0" encoding="utf-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:asy="ms.banque.async">
  <soapenv:Body>
    <asy:UploadCheque>
      <asy:request_id>YOUR_REQUEST_ID</asy:request_id>
      <asy:cheque>valid</asy:cheque>
    </asy:UploadCheque>
  </soapenv:Body>
</soapenv:Envelope>'
```

**Réponse attendue**

```
HTTP/1.0 200 OK
```

---

### Étape 4 – GetChequeStatus (après dépôt)

```
curl -X POST http://localhost:5002/ \
  -H "Content-Type: text/xml; charset=utf-8" \
  --data '<?xml version="1.0" encoding="utf-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:asy="ms.banque.async">
  <soapenv:Body>
    <asy:GetChequeStatus>
      <asy:request_id>YOUR_REQUEST_ID</asy:request_id>
    </asy:GetChequeStatus>
  </soapenv:Body>
</soapenv:Envelope>'
```

**Réponse attendue**

```xml
<soap11env:Envelope …>
  <soap11env:Body>
    <tns:GetChequeStatusResponse>
      <tns:GetChequeStatusResult>
        <tns:status>done</tns:status>
        <tns:verdict>Chèque validé</tns:verdict>
      </tns:GetChequeStatusResult>
    </tns:GetChequeStatusResponse>
  </soap11env:Body>
</soap11env:Envelope>
```

---

### Cas « Chèque invalide »

Reprenez **étape 3** en mettant `<asy:cheque>invalid</asy:cheque>`, puis **étape 4** :
vous verrez `verdict=Chèque invalide`.

---

## Workflow détaillé

* **SubmitChequeRequest** : stocke `{status: pending, reply_to, relates_to}` en Redis + renvoie `request_id`
* **GetChequeStatus** : lit Redis et renvoie `status + verdict`
* **UploadCheque** : met à jour `{status: done, verdict}`, lance un callback SOAP vers `ReplyTo` (facultatif)

---

Vous disposez désormais d’un guide complet pour déployer et tester manuellement toutes les opérations de **ms\_banque**.

================================================================================
Chemin relatif: src/app/requirements.txt
flask
grpcio
requests
protobuf

================================================================================
Chemin relatif: src/app/__init__.py

================================================================================
Chemin relatif: src/app/Dockerfile
FROM python:3.10-slim

WORKDIR /app

# pour healthchecks (netcat) et curl
RUN apt-get update && apt-get install -y netcat-openbsd curl

# 1) installer les dépendances Python
COPY src/app/requirements.txt .
RUN pip install --upgrade pip && pip install -r requirements.txt

# 2) copier l'app Flask
COPY src/app /app

# 3) copier le dossier ms_montantmax
COPY src/ms_montantmax /app/ms_montantmax

# 4) ajouter ms_montantmax à PYTHONPATH pour les imports top-level
ENV PYTHONPATH="/app/ms_montantmax:${PYTHONPATH}"

EXPOSE 5000

HEALTHCHECK --interval=10s --timeout=5s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:5000/health || exit 1

CMD ["python", "app.py"]

================================================================================
Chemin relatif: src/app/app.py
#!/usr/bin/env python3
"""
Application compagnon pour la gestion des demandes de prêt.
Orchestre les appels aux microservices et supporte le workflow asynchrone pour le chèque.
"""
from flask import Flask, request, jsonify
import requests
import grpc
import uuid
from xml.etree import ElementTree as ET
from ms_montantmax import montantmax_pb2, montantmax_pb2_grpc

app = Flask(__name__)

# Config des microservices
MS_MONTANTMAX_ADDRESS = 'localhost:50051'
MS_PROFILRISQUE_URL  = 'http://localhost:5001/graphql'
MS_BANQUE_URL         = 'http://localhost:5002/'   # SOAP async
MS_FOURNISSEUR_URL    = 'http://localhost:5003/fundTransfers'

# Stockage en mémoire des demandes (pour tests/demo)
_loans = {}

@app.route('/health', methods=['GET'])
def health():
    return jsonify({"status": "ok"}), 200

@app.route('/loan', methods=['POST'])
def loan_request():
    data = request.get_json(silent=True)
    if not data:
        return jsonify({"status": "error", "reason": "Données de requête manquantes"}), 400

    client_id     = data.get("id")
    personal_info = data.get("personal_info")
    loan_amount   = data.get("loan_amount")
    if client_id is None or personal_info is None or loan_amount is None:
        return jsonify({"status": "error", "reason": "Paramètres requis manquants"}), 400

    # Montant en float
    try:
        loan_amount = float(loan_amount)
    except (ValueError, TypeError):
        return jsonify({"status": "error", "reason": "Le montant doit être un nombre"}), 400

    # 1. Vérification gRPC MontantMax
    try:
        channel = grpc.insecure_channel(MS_MONTANTMAX_ADDRESS)
        stub    = montantmax_pb2_grpc.MontantMaxServiceStub(channel)
        resp    = stub.CheckLoan(montantmax_pb2.LoanRequest(loan_amount=loan_amount))
    except Exception:
        return jsonify({"status": "error", "reason": "Erreur vérification montant"}), 500

    if not resp.allowed:
        return jsonify({"status": "refused", "reason": resp.message}), 400

    # 2. Vérification profil de risque (GraphQL)
    query = '''
      query($loanAmount: Float!, $clientInfo: String!) {
        riskProfile(loanAmount: $loanAmount, clientInfo: $clientInfo)
      }
    '''
    try:
        gql = requests.post(
          MS_PROFILRISQUE_URL,
          json={'query': query, 'variables': {'loanAmount': loan_amount, 'clientInfo': personal_info}},
          timeout=5
        )
        risk = gql.json().get('riskProfile')
    except Exception:
        return jsonify({"status": "error", "reason": "Erreur profil risque"}), 500

    if risk == 'elevé' and loan_amount >= 20000:
        return jsonify({"status": "refused", "reason": "Risque trop élevé"}), 400

    # 3. SubmitChequeRequest (asynchrone) → on récupère request_id
    soap = f'''<?xml version="1.0"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  <soapenv:Body>
    <SubmitChequeRequest xmlns="ms.banque.async"/>
  </soapenv:Body>
</soapenv:Envelope>'''
    try:
        headers = {'Content-Type': 'application/soap+xml; charset=utf-8'}
        r = requests.post(MS_BANQUE_URL, data=soap, headers=headers, timeout=5)
        tree = ET.fromstring(r.content)
        ns   = {'soap11env': 'http://schemas.xmlsoap.org/soap/envelope/',
                'tns':       'ms.banque.async'}
        req_id = tree.findtext('.//tns:SubmitChequeRequestResult', namespaces=ns)
    except Exception:
        return jsonify({"status": "error", "reason": "Erreur dépôt chèque"}), 500

    # On stocke l'état initial
    _loans[req_id] = {
        'client_id':   client_id,
        'loan_amount': loan_amount,
        'status':      'pending'
    }

    return jsonify({
        "status":     "pending",
        "request_id": req_id,
        "message":    "Veuillez déposer votre chèque en utilisant cet ID"
    }), 200

@app.route('/loan/status/<request_id>', methods=['GET'])
def loan_status(request_id):
    entry = _loans.get(request_id)
    if not entry:
        return jsonify({"status": "error", "reason": "ID inconnu"}), 404

    if entry['status'] == 'pending':
        return jsonify({"status": "pending"}), 200

    # état 'done'
    verdict = entry.get('verdict', '')
    if verdict == 'Chèque validé':
        return jsonify({"status": "approved", "message": "Prêt approuvé et fonds transférés"}), 200
    else:
        return jsonify({"status": "refused", "reason": "Chèque invalide"}), 400

@app.route('/loan/callback', methods=['POST'])
def loan_callback():
    # Point de callback SOAP asynchrone
    content = request.data
    tree    = ET.fromstring(content)
    # On extrait simplement les balises <request_id> et <verdict>
    req_id  = tree.findtext('.//request_id')
    verdict = tree.findtext('.//verdict')

    entry = _loans.get(req_id)
    if not entry:
        return '', 404

    entry['status']  = 'done'
    entry['verdict'] = verdict or ''

    # Si validé, on appelle MS_FOURNISSEUR pour débloquer les fonds
    if verdict == 'Chèque validé':
        requests.post(
          MS_FOURNISSEUR_URL,
          json={'loan_amount': entry['loan_amount'], 'client_id': entry['client_id']},
          timeout=5
        )
    return '', 200

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)

================================================================================
Chemin relatif: src/app/.pytest_cache/CACHEDIR.TAG
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

================================================================================
Chemin relatif: src/app/.pytest_cache/README.md
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

================================================================================
Chemin relatif: src/app/.pytest_cache/v/cache/stepwise
[]
================================================================================
Chemin relatif: src/app/.pytest_cache/v/cache/lastfailed
{
  "test_app.py": true
}
================================================================================
Chemin relatif: src/app/.pytest_cache/v/cache/nodeids
[]
================================================================================
Chemin relatif: src/ms_montantmax/__init__.py

================================================================================
Chemin relatif: src/ms_montantmax/Dockerfile
# Utiliser l'image Python 3.13-slim
FROM python:3.13-slim

# Définir le répertoire de travail dans le container sur /app
WORKDIR /app

# Installer curl et netcat-openbsd pour les healthchecks
RUN apt-get update && apt-get install -y netcat-openbsd

# Ajouter le dossier contenant les modules générés au PYTHONPATH
ENV PYTHONPATH="/app/ms_montantmax:${PYTHONPATH}"

# Copier le dossier ms_montantmax dans /app
COPY . ./ms_montantmax

# Installer les dépendances Python (grpcio et grpcio-tools)
RUN pip install --upgrade pip && \
    pip install grpcio grpcio-tools

# Exposer le port utilisé par le service gRPC
EXPOSE 50051

# Lancer le service gRPC en utilisant le module dans le package
CMD ["python", "-m", "ms_montantmax.server"]

================================================================================
Chemin relatif: src/ms_montantmax/server.py
# src/ms_montantmax/server.py
from concurrent import futures
import grpc
from ms_montantmax import montantmax_pb2
from ms_montantmax import montantmax_pb2_grpc

# Définir la classe de service en étendant la classe générée par gRPC
class MontantMaxService(montantmax_pb2_grpc.MontantMaxServiceServicer):
    def CheckLoan(self, request, context):
        # Par exemple, définissons un plafond autorisé
        plafond = 50000
        if request.loan_amount <= plafond:
            return montantmax_pb2.LoanResponse(
                allowed=True,
                message="Demande acceptée"
            )
        else:
            return montantmax_pb2.LoanResponse(
                allowed=False,
                message="Montant trop élevé"
            )

def serve():
    # Créer un serveur gRPC avec un pool de threads
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    # Ajouter notre service au serveur
    montantmax_pb2_grpc.add_MontantMaxServiceServicer_to_server(MontantMaxService(), server)
    # Écouter sur le port 5001
    server.add_insecure_port('[::]:50051')
    server.start()
    print("MS MontantMax gRPC server is running on port 50051")
    server.wait_for_termination()

if __name__ == '__main__':
    serve()

================================================================================
Chemin relatif: src/ms_montantmax/montantmax_pb2.py
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: montantmax.proto
# Protobuf Python Version: 5.29.0
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    5,
    29,
    0,
    '',
    'montantmax.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x10montantmax.proto\x12\rms_montantmax\"\"\n\x0bLoanRequest\x12\x13\n\x0bloan_amount\x18\x01 \x01(\x02\"0\n\x0cLoanResponse\x12\x0f\n\x07\x61llowed\x18\x01 \x01(\x08\x12\x0f\n\x07message\x18\x02 \x01(\t2Y\n\x11MontantMaxService\x12\x44\n\tCheckLoan\x12\x1a.ms_montantmax.LoanRequest\x1a\x1b.ms_montantmax.LoanResponseb\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'montantmax_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  DESCRIPTOR._loaded_options = None
  _globals['_LOANREQUEST']._serialized_start=35
  _globals['_LOANREQUEST']._serialized_end=69
  _globals['_LOANRESPONSE']._serialized_start=71
  _globals['_LOANRESPONSE']._serialized_end=119
  _globals['_MONTANTMAXSERVICE']._serialized_start=121
  _globals['_MONTANTMAXSERVICE']._serialized_end=210
# @@protoc_insertion_point(module_scope)

================================================================================
Chemin relatif: src/ms_montantmax/Readme.md
Pour tester:
```sh
docker build -t ms_montantmax .
docker run -d -p 50051:50051 ms_montantmax

```

Dans un autre terminal : (depuis ms_montantmax)
```sh
grpcurl -plaintext -proto ms_montantmax/montantmax.proto -d '{"loan_amount": 30000}' localhost:50051 ms_montantmax.MontantMaxService/CheckLoan
```
Dans un autre terminal : (depuis le fichier racines)
```sh
grpcurl -plaintext -proto src/ms_montantmax/montantmax.proto -d '{"loan_amount": 30000}' localhost:50051 ms_montantmax.MontantMaxService/CheckLoan
```

Réponse : 
```sh
{
  "allowed": true,
  "message": "Demande acceptée"
}
```


Ou alors :
Dans un autre terminal :
```sh
grpcurl -plaintext -proto ms_montantmax/montantmax.proto -d '{"loan_amount": 60000}' localhost:50051 ms_montantmax.MontantMaxService/CheckLoan
```

Réponse : 
```sh
{
  "message": "Montant trop élevé"
}
```
================================================================================
Chemin relatif: src/ms_montantmax/montantmax.proto
// src/ms_montantmax/montantmax.proto
syntax = "proto3";

package ms_montantmax;

// Définition du service gRPC
service MontantMaxService {
  // Méthode pour vérifier le montant du prêt
  rpc CheckLoan(LoanRequest) returns (LoanResponse);
}

// Message de requête contenant le montant demandé
message LoanRequest {
  float loan_amount = 1;
}

// Message de réponse indiquant si le montant est autorisé et un message associé
message LoanResponse {
  bool allowed = 1;
  string message = 2;
}

================================================================================
Chemin relatif: src/ms_montantmax/montantmax_pb2_grpc.py
# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

import montantmax_pb2 as montantmax__pb2

GRPC_GENERATED_VERSION = '1.71.0'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in montantmax_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class MontantMaxServiceStub(object):
    """Définition du service gRPC
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.CheckLoan = channel.unary_unary(
                '/ms_montantmax.MontantMaxService/CheckLoan',
                request_serializer=montantmax__pb2.LoanRequest.SerializeToString,
                response_deserializer=montantmax__pb2.LoanResponse.FromString,
                _registered_method=True)


class MontantMaxServiceServicer(object):
    """Définition du service gRPC
    """

    def CheckLoan(self, request, context):
        """Méthode pour vérifier le montant du prêt
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_MontantMaxServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'CheckLoan': grpc.unary_unary_rpc_method_handler(
                    servicer.CheckLoan,
                    request_deserializer=montantmax__pb2.LoanRequest.FromString,
                    response_serializer=montantmax__pb2.LoanResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'ms_montantmax.MontantMaxService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('ms_montantmax.MontantMaxService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class MontantMaxService(object):
    """Définition du service gRPC
    """

    @staticmethod
    def CheckLoan(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/ms_montantmax.MontantMaxService/CheckLoan',
            montantmax__pb2.LoanRequest.SerializeToString,
            montantmax__pb2.LoanResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

================================================================================
Chemin relatif: src/ms_profilrisque/__init__.py

================================================================================
Chemin relatif: src/ms_profilrisque/Dockerfile
# Utiliser une image Python 3.10 slim
FROM python:3.13-slim

# Définir le répertoire de travail dans le conteneur
WORKDIR /app

# Installer curl et netcat-openbsd pour les healthchecks
RUN apt-get update && apt-get install -y curl

# Installer les dépendances nécessaires : Flask et Graphene
RUN pip install --upgrade pip && \
    pip install flask graphene

# Copier le code source dans le conteneur
COPY . .

# Exposer le port utilisé (ici 5001)
EXPOSE 5001

# Lancer l’application
CMD ["python", "server.py"]

================================================================================
Chemin relatif: src/ms_profilrisque/server.py
# src/ms_profilrisque/app.py
from flask import Flask, request, jsonify
from graphene import ObjectType, String, Schema, Float

class Query(ObjectType):
    riskProfile = String(loanAmount=Float(required=True), clientInfo=String(required=True))

    def resolve_riskProfile(root, info, loanAmount, clientInfo):
        # Implémentez ici la logique d'analyse du risque.
        # Par exemple, si le montant est élevé, on renvoie "elevé"
        if loanAmount >= 20000:
            return "elevé"
        else:
            return "acceptable"

schema = Schema(query=Query)

app = Flask(__name__)

@app.route("/graphql", methods=["POST"])
def graphql_server():
    data = request.get_json()
    result = schema.execute(data.get("query"), variables=data.get("variables"))
    return jsonify(result.data)

@app.route('/health', methods=['GET'])
def health():
    return jsonify({"status": "ok"}), 200

if __name__ == '__main__':
    app.run(host="0.0.0.0", port=5001)

================================================================================
Chemin relatif: src/ms_profilrisque/Readme.md
Pour tester:
```sh
python server.py
```
Ou en docker :
```sh
docker build -t ms_profilrisque .
docker run -d -p 5001:5001 ms_profilrisque
```

Dans un autre terminal :
```sh
curl http://localhost:5001/health
```

```sh
curl -X POST -H "Content-Type: application/json" \
-d '{
      "query": "query($loanAmount: Float!, $clientInfo: String!){ riskProfile(loanAmount: $loanAmount, clientInfo: $clientInfo) }",
      "variables": {"loanAmount": 25000, "clientInfo": "Information client exemple"}
    }' \
http://localhost:5001/graphql

```

Réponse : hrg
```sh
{"riskProfile":"elev\u00e9"}
```
================================================================================
